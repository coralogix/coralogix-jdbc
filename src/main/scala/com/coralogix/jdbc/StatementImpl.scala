package com.coralogix.jdbc

import com.coralogix.sql.grpc.external.v1.SqlQueryService.ZioSqlQueryService.SqlQueryServiceClient
import com.coralogix.sql.grpc.external.v1.SqlQueryService.{ QueryParameter, QueryRequest }
import io.grpc.Status
import zio.duration._
import zio.{ Cause, Fiber, Runtime, UIO, ZIO }

import java.sql._
import scala.annotation.nowarn

class StatementImpl(
  rt: Runtime[SqlQueryServiceClient],
  connection: ConnectionImpl,
  var queryTimeout: Int
) extends Statement with UnsupportedStatementMethods {

  var resultSet: ResultSetImpl = null
  var cursorName = "cursor"
  var closed = false
  var closeOnCompletionx = false
  var fiber: Fiber[Status, ResultSetImpl] = null
  // FIXME leave default?
  // FIXME actually use it in query
  var fetchSize = 100

  protected def callGrpc(sql: String, parameters: Seq[QueryParameter]): ResultSetImpl =
    rt.unsafeRunTask(
      (for {
        grpcFiber <- SqlQueryServiceClient
                       .withTimeout(queryTimeout.seconds)
                       .runQuery(
                         QueryRequest(
                           sql,
                           parameters
                         )
                       )
                       .map(ResultSetImpl(_, cursorName, this))
                       .flatMap(rs => UIO { resultSet = rs; rs })
                       .forkDaemon
        _ <- UIO { fiber = grpcFiber }
        _ <- fiber.join.ensuring(UIO { fiber = null })
      } yield this.resultSet).foldCauseM(
        _.foldLeft(ZIO.fail(new SQLException("Empty cause received"))) {
          case (_, Cause.Interrupt(_)) =>
            ZIO.fail(new SQLException("Statement cancelled due to client request"))
          case (_, Cause.Fail(status)) =>
            ZIO.fail(
              new SQLException(
                s"Statement failed: ${Option(status.getDescription).getOrElse(status.getCode.name)}"
              )
            )
          case (_, Cause.Die(e)) => ZIO.fail(new SQLException(e))
        },
        ZIO.succeed(_)
      )
    )

  override def executeQuery(sql: String): ResultSet =
    callGrpc(sql, Seq.empty)

  override def close(): Unit =
    closed = true

  override def getQueryTimeout: Int = queryTimeout

  override def setQueryTimeout(seconds: Int): Unit =
    queryTimeout = seconds

  @nowarn("cat=w-flag-value-discard")
  override def cancel(): Unit =
    if (fiber != null)
      rt.unsafeRun(fiber.interrupt)

  override def getWarnings: SQLWarning = null

  override def clearWarnings(): Unit = ()

  override def setCursorName(name: String): Unit =
    cursorName = name

  override def execute(sql: String): Boolean = {
    callGrpc(sql, Seq.empty)
    true
  }

  override def getResultSet: ResultSet = resultSet

  override def getUpdateCount: Int = -1

  override def getMoreResults: Boolean = false

  override def getFetchDirection: Int = 0

  override def setFetchSize(rows: Int): Unit =
    fetchSize = rows

  override def getFetchSize: Int = fetchSize

  override def getResultSetConcurrency: Int =
    ResultSet.CONCUR_READ_ONLY

  override def getResultSetType: Int =
    ResultSet.TYPE_FORWARD_ONLY

  override def getConnection: Connection =
    connection

  override def getMoreResults(current: Int): Boolean = false

  override def execute(sql: String, autoGeneratedKeys: Int): Boolean = {
    if (autoGeneratedKeys != Statement.NO_GENERATED_KEYS)
      throw new SQLNonTransientException("Auto generated keys are not supported")
    callGrpc(sql, Seq.empty)
    true
  }

  override def getResultSetHoldability: Int =
    ResultSet.HOLD_CURSORS_OVER_COMMIT

  override def isClosed: Boolean = closed

  override def isPoolable: Boolean = false

  override def closeOnCompletion(): Unit =
    closeOnCompletionx = true

  override def isCloseOnCompletion: Boolean = closeOnCompletionx

  override def getMaxRows: Int = 0

  override def setMaxRows(max: Int): Unit = ()

  override def isWrapperFor(iface: Class[_]): Boolean = false
}
